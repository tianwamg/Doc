### Lock--锁

1. JDK锁
   1. sychronized

```
	 0: ldc   #2   // class juc/Synchronized
         2: dup
         3: astore_1
         4: monitorenter   // 这里
         5: aload_1
         6: monitorexit    // 这里
         7: goto          15
        10: astore_2
        11: aload_1
        12: monitorexit    // 这里
        13: aload_2
        14: athrow
        15: return

```                
- 为什么一个加锁操作，却有两次释放？原因：一次正常释放锁，一次为程序异常释放
- 使用场景：

![8f00ae410957db339e15d1211067b55d](https://user-images.githubusercontent.com/29136753/132813222-da66f236-63e9-4ee1-90c2-39b1c0f5e043.png)


- 可重入 : 线程对象会拥有一个计数器，每当线程获取到锁对象时计数器+1，释放-1，值为0时完全释放锁，不为0时该线程可以无需竞争即可获取锁;

- Java对象头
    - 同一时刻只用一个线程可以获取到对象的监视器。Java对象头里的MarkWorld默认存放对象的hashcode,分代年龄和锁标记位。

![image](https://user-images.githubusercontent.com/29136753/132813389-bd9faf13-5c92-4c2b-9971-c5337a828cd5.png)


- 锁状态

![image](https://user-images.githubusercontent.com/29136753/132813476-9347d7f7-fab1-4190-9552-4389ff0d8c4d.png)

- 无锁
- 偏向锁
- 轻量级锁
- 重量级锁


    2. Lock

2. 分布式锁
    1. Redis
    2. zookeeper

> 大脑：好的，我都已经会了!
> 手：MD真笨，键盘倒是敲啊！
